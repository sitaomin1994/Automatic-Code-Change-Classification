{"application": "google-guava", "csha": "3a26a954c12ce3ba0540f93f7be62fc011304748", "files": [{"GraphProperties_cluster": {"actions": [{"root": "MOVE from CompilationUnit", "operations": ["MOV ImportDeclaration to CompilationUnit at 3"]}, {"root": "INS ImportDeclaration to CompilationUnit at 5", "operations": ["INS ImportDeclaration to CompilationUnit at 5", "INS QualifiedName: javax.annotation.Nullable to ImportDeclaration at 0"]}, {"root": "UPDATE from com.google.common.base.Preconditions.checkArgument to com.google.common.base.Objects", "operations": ["UPD QualifiedName: com.google.common.base.Preconditions.checkArgument from com.google.common.base.Preconditions.checkArgument to com.google.common.base.Objects"]}, {"root": "INS MethodDeclaration to TypeDeclaration: class at 9", "operations": ["INS TextElement: case, we must take care not to \"backtrack\" over an edge (i.e. going from A to B and then going to TagElement at 2", "INS SimpleName: isDirected to MethodInvocation at 1", "INS SingleVariableDeclaration to MethodDeclaration at 7", "INS IfStatement to Block at 0", "INS SimpleType: Graph to ParameterizedType: Graph<?> at 0", "INS SingleVariableDeclaration to MethodDeclaration at 5", "INS TextElement: Determines whether an edge has already been used during traversal. In the directed case a cycle to TagElement at 0", "INS Modifier: private to MethodDeclaration at 1", "INS SimpleName: previousNode to MethodInvocation at 2", "INS TagElement to Javadoc at 0", "INS SimpleType: Object to SingleVariableDeclaration at 0", "INS Block to MethodDeclaration at 8", "INS SimpleName: nextNode to MethodInvocation at 3", "INS ReturnStatement to Block at 1", "INS Block to IfStatement at 1", "INS BooleanLiteral: true to ReturnStatement at 0", "INS SimpleName: equal to MethodInvocation at 1", "INS PrefixExpression: ! to InfixExpression: || at 1", "INS SimpleName: Nullable to MarkerAnnotation at 0", "INS SimpleName: previousNode to SingleVariableDeclaration at 2", "INS ReturnStatement to Block at 0", "INS PrimitiveType: boolean to MethodDeclaration at 3", "INS SimpleName: Objects to MethodInvocation at 0", "INS Javadoc to MethodDeclaration at 0", "INS TextElement: from B to A). to TagElement at 3", "INS WildcardType: ? to ParameterizedType: Graph<?> at 1", "INS SimpleName: Graph to SimpleType: Graph at 0", "INS ParameterizedType: Graph<?> to SingleVariableDeclaration at 0", "INS Modifier: static to MethodDeclaration at 2", "INS MethodInvocation to PrefixExpression: ! at 0", "INS SimpleName: graph to MethodInvocation at 0", "INS MethodDeclaration to TypeDeclaration: class at 9", "INS SimpleName: nextNode to SingleVariableDeclaration at 1", "INS MethodInvocation to InfixExpression: || at 0", "INS SimpleName: Object to SimpleType: Object at 0", "INS BooleanLiteral: false to ReturnStatement at 0", "INS SimpleName: graph to SingleVariableDeclaration at 1", "INS TextElement: is always detected before reusing an edge, so no special logic is required. In the undirected to TagElement at 1", "INS MarkerAnnotation to SingleVariableDeclaration at 0", "INS SimpleType: Object to SingleVariableDeclaration at 1", "INS SingleVariableDeclaration to MethodDeclaration at 6", "INS SimpleName: Object to SimpleType: Object at 0", "INS SimpleName: canTraverseWithoutReusingEdge to MethodDeclaration at 4", "INS InfixExpression: || to IfStatement at 0"]}, {"root": "INS SingleVariableDeclaration to MethodDeclaration at 8", "operations": ["INS SimpleName: Object to SimpleType: Object at 0", "INS SimpleName: previousNode to SingleVariableDeclaration at 2", "INS SimpleName: Nullable to MarkerAnnotation at 0", "INS SingleVariableDeclaration to MethodDeclaration at 8", "INS SimpleType: Object to SingleVariableDeclaration at 1", "INS MarkerAnnotation to SingleVariableDeclaration at 0"]}, {"root": "INS Block to MethodDeclaration at 9", "operations": ["INS Block to EnhancedForStatement at 2", "INS ExpressionStatement to Block at 3", "INS Block to IfStatement at 1", "INS SimpleName: put to MethodInvocation at 1", "INS QualifiedName: NodeState.PENDING to MethodInvocation at 3", "INS IfStatement to Block at 1", "INS BooleanLiteral: false to ReturnStatement at 0", "INS IfStatement to Block at 2", "INS SimpleName: node to MethodInvocation at 2", "INS EnhancedForStatement to Block at 4", "INS SimpleName: visitedNodes to MethodInvocation at 0", "INS ReturnStatement to Block at 0", "INS MethodInvocation to ExpressionStatement at 0", "INS Block to MethodDeclaration at 9"]}, {"root": "UPDATE from NodeVisitState to NodeState", "operations": ["UPD SimpleName: NodeVisitState from NodeVisitState to NodeState", "UPD SimpleName: NodeVisitState from NodeVisitState to NodeState", "UPD SimpleType: NodeVisitState from NodeVisitState to NodeState", "UPD SimpleType: NodeVisitState from NodeVisitState to NodeState", "UPD SimpleName: NodeVisitState from NodeVisitState to NodeState", "UPD SimpleType: NodeVisitState from NodeVisitState to NodeState", "UPD SimpleName: NodeVisitState from NodeVisitState to NodeState"]}, {"root": "INS IfStatement to Block at 2", "operations": ["INS SimpleName: numEdges to InfixExpression: == at 0", "INS ReturnStatement to Block at 0", "INS IfStatement to Block at 2", "INS BooleanLiteral: false to ReturnStatement at 0", "INS Block to IfStatement at 1", "INS NumberLiteral: 0 to InfixExpression: == at 1", "INS InfixExpression: == to IfStatement at 0"]}, {"root": "INS IfStatement to Block at 3", "operations": ["INS IfStatement to Block at 3", "INS InfixExpression: >= to InfixExpression: && at 1", "INS InfixExpression: && to IfStatement at 0", "INS PrefixExpression: ! to InfixExpression: && at 0", "INS SimpleName: numEdges to InfixExpression: >= at 0"]}, {"root": "INS VariableDeclarationStatement to Block at 4", "operations": ["INS SimpleName: size to MethodInvocation at 1", "INS MethodInvocation to MethodInvocation at 2", "INS SimpleName: Maps to MethodInvocation at 0", "INS VariableDeclarationStatement to Block at 4", "INS SimpleName: visitedNodes to VariableDeclarationFragment at 0", "INS SimpleName: graph to MethodInvocation at 0", "INS VariableDeclarationFragment to VariableDeclarationStatement at 1", "INS MethodInvocation to MethodInvocation at 0", "INS SimpleName: newHashMapWithExpectedSize to MethodInvocation at 1", "INS MethodInvocation to VariableDeclarationFragment at 1", "INS SimpleName: nodes to MethodInvocation at 1"]}, {"root": "INS EnhancedForStatement to Block at 5", "operations": ["INS EnhancedForStatement to Block at 5", "INS Block to EnhancedForStatement at 2"]}, {"root": "INS IfStatement to Block at 0", "operations": ["INS SimpleName: isDirected to MethodInvocation at 1", "INS SimpleName: size to MethodInvocation at 1", "INS InfixExpression: > to InfixExpression: && at 2", "INS MethodInvocation to PrefixExpression: ! at 0", "INS SimpleName: network to MethodInvocation at 0", "INS InfixExpression: && to IfStatement at 0", "INS PrefixExpression: ! to InfixExpression: && at 0", "INS MethodInvocation to InfixExpression: > at 0", "INS SimpleName: size to MethodInvocation at 1", "INS MethodInvocation to MethodInvocation at 0", "INS SimpleName: edges to MethodInvocation at 1", "INS IfStatement to Block at 0", "INS SimpleName: network to MethodInvocation at 0", "INS MethodInvocation to MethodInvocation at 0", "INS MethodInvocation to InfixExpression: > at 1", "INS SimpleName: network to MethodInvocation at 0", "INS MethodInvocation to MethodInvocation at 0", "INS SimpleName: network to MethodInvocation at 0", "INS SimpleName: allowsParallelEdges to MethodInvocation at 1", "INS SimpleName: edges to MethodInvocation at 1", "INS SimpleName: asGraph to MethodInvocation at 1", "INS MethodInvocation to InfixExpression: && at 1"]}, {"root": "MOVE from TagElement", "operations": ["MOV TextElement:  reachable from to TagElement at 4"]}, {"root": "UPDATE from Map<Object,NodeVisitState> to Map<Object,NodeState>", "operations": ["UPD ParameterizedType: Map<Object,NodeVisitState> from Map<Object,NodeVisitState> to Map<Object,NodeState>", "UPD ParameterizedType: Map<Object,NodeVisitState> from Map<Object,NodeVisitState> to Map<Object,NodeState>"]}, {"root": "UPDATE from nodeToVisitState to visitedNodes", "operations": ["UPD SimpleName: nodeToVisitState from nodeToVisitState to visitedNodes", "UPD SimpleName: nodeToVisitState from nodeToVisitState to visitedNodes", "UPD SimpleName: nodeToVisitState from nodeToVisitState to visitedNodes", "UPD SimpleName: nodeToVisitState from nodeToVisitState to visitedNodes"]}, {"root": "MOVE from Block", "operations": ["MOV VariableDeclarationStatement to Block at 0"]}, {"root": "MOVE from Block", "operations": ["MOV ExpressionStatement to Block at 5", "MOV ReturnStatement to Block at 6"]}, {"root": "UPDATE from  has at least one cycle. to  has at least one cycle. A cycle is defined as a non-empty", "operations": ["UPD TextElement:  has at least one cycle. from  has at least one cycle. to  has at least one cycle. A cycle is defined as a non-empty"]}, {"root": "INS TextElement: subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges) to TagElement at 3", "operations": ["INS TextElement: subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges) to TagElement at 3"]}, {"root": "INS TextElement: starting and ending with the same node. to TagElement at 4", "operations": ["INS TextElement: starting and ending with the same node. to TagElement at 4"]}, {"root": "INS TextElement: <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1). to TagElement at 5", "operations": ["INS TextElement: <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1). to TagElement at 5"]}, {"root": "INS PrimitiveType: int to VariableDeclarationStatement at 0", "operations": ["INS PrimitiveType: int to VariableDeclarationStatement at 0"]}, {"root": "MOVE from IfStatement", "operations": ["MOV Block to IfStatement at 1"]}, {"root": "MOVE from VariableDeclarationStatement", "operations": ["MOV ParameterizedType: Map<Object,NodeVisitState> to VariableDeclarationStatement at 0"]}, {"root": "MOVE from EnhancedForStatement", "operations": ["MOV SingleVariableDeclaration to EnhancedForStatement at 0", "MOV MethodInvocation to EnhancedForStatement at 1"]}, {"root": "UPDATE from See  to Returns true iff ", "operations": ["UPD TextElement: See  from See  to Returns true iff "]}, {"root": "UPDATE from @link to @code", "operations": ["UPD TagElement: @link from @link to @code"]}, {"root": "INS TextElement:  has at least one cycle. A cycle is defined as a non-empty to TagElement at 2", "operations": ["INS TextElement:  has at least one cycle. A cycle is defined as a non-empty to TagElement at 2"]}, {"root": "INS TextElement: subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges) to TagElement at 3", "operations": ["INS TextElement: subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges) to TagElement at 3"]}, {"root": "UPDATE from . to starting and ending with the same node.", "operations": ["UPD TextElement: . from . to starting and ending with the same node."]}, {"root": "INS TextElement: <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1). to TagElement at 5", "operations": ["INS TextElement: <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1). to TagElement at 5"]}, {"root": "MOVE from IfStatement", "operations": ["MOV Block to IfStatement at 1", "MOV InfixExpression: == to IfStatement at 0"]}, {"root": "UPDATE from Returns true iff there is a cycle in the subgraph of  to Performs a traversal of the nodes reachable from ", "operations": ["UPD TextElement: Returns true iff there is a cycle in the subgraph of  from Returns true iff there is a cycle in the subgraph of  to Performs a traversal of the nodes reachable from "]}, {"root": "UPDATE from  graph to . If we ever reach a node we've", "operations": ["UPD TextElement:  graph from  graph to . If we ever reach a node we've"]}, {"root": "MOVE from TagElement", "operations": ["MOV TextElement:  graph to TagElement at 3"]}, {"root": "UPDATE from  reachable from to already visited (following only outgoing edges and without reusing edges), we know there's a", "operations": ["UPD TextElement:  reachable from from  reachable from to already visited (following only outgoing edges and without reusing edges), we know there's a"]}, {"root": "UPDATE from . to cycle in the graph.", "operations": ["UPD TextElement: . from . to cycle in the graph."]}, {"root": "MOVE from IfStatement", "operations": ["MOV InfixExpression: == to IfStatement at 0"]}, {"root": "MOVE from IfStatement", "operations": ["MOV Block to IfStatement at 1"]}, {"root": "MOVE from EnhancedForStatement", "operations": ["MOV MethodInvocation to EnhancedForStatement at 1", "MOV SingleVariableDeclaration to EnhancedForStatement at 0"]}, {"root": "UPDATE from nodeToVisitState to numEdges", "operations": ["UPD SimpleName: nodeToVisitState from nodeToVisitState to numEdges"]}, {"root": "MOVE from Block", "operations": ["MOV IfStatement to Block at 0"]}, {"root": "INS TextElement:  network to TagElement: @link at 0", "operations": ["INS TextElement:  network to TagElement: @link at 0"]}, {"root": "UPDATE from nodeVisitState to state", "operations": ["UPD SimpleName: nodeVisitState from nodeVisitState to state", "UPD SimpleName: nodeVisitState from nodeVisitState to state", "UPD SimpleName: nodeVisitState from nodeVisitState to state"]}, {"root": "UPDATE from NodeVisitState.PENDING to NodeState.COMPLETE", "operations": ["UPD QualifiedName: NodeVisitState.PENDING from NodeVisitState.PENDING to NodeState.COMPLETE", "UPD QualifiedName: NodeVisitState.COMPLETE from NodeVisitState.COMPLETE to NodeState.COMPLETE"]}, {"root": "INS QualifiedName: NodeState.PENDING to InfixExpression: == at 1", "operations": ["INS QualifiedName: NodeState.PENDING to InfixExpression: == at 1"]}, {"root": "UPDATE from nodeToVisitState to nextNode", "operations": ["UPD SimpleName: nodeToVisitState from nodeToVisitState to nextNode", "UPD SimpleName: successor from successor to nextNode"]}, {"root": "MOVE from Block", "operations": ["MOV IfStatement to Block at 0"]}, {"root": "INS MethodInvocation to MethodInvocation at 0", "operations": ["INS SimpleName: graph to MethodInvocation at 0", "INS MethodInvocation to MethodInvocation at 0"]}, {"root": "UPDATE from node to size", "operations": ["UPD SimpleName: node from node to size", "UPD SimpleName: newHashMap from newHashMap to size"]}, {"root": "MOVE from PrefixExpression: !", "operations": ["MOV MethodInvocation to PrefixExpression: ! at 0"]}, {"root": "MOVE from InfixExpression: >=", "operations": ["MOV MethodInvocation to InfixExpression: >= at 1"]}, {"root": "INS Block to IfStatement at 1", "operations": ["INS BooleanLiteral: true to ReturnStatement at 0", "INS ReturnStatement to Block at 0", "INS Block to IfStatement at 1"]}, {"root": "UPDATE from successor to node", "operations": ["UPD SimpleName: successor from successor to node", "UPD SimpleName: successor from successor to node"]}, {"root": "INS InfixExpression: && to IfStatement at 0", "operations": ["INS InfixExpression: && to IfStatement at 0", "INS SimpleName: nextNode to MethodInvocation at 2", "INS SimpleName: visitedNodes to MethodInvocation at 2", "INS SimpleName: previousNode to MethodInvocation at 3", "INS MethodInvocation to InfixExpression: && at 0", "INS MethodInvocation to InfixExpression: && at 1", "INS SimpleName: canTraverseWithoutReusingEdge to MethodInvocation at 0", "INS SimpleName: graph to MethodInvocation at 1"]}, {"root": "INS Block to IfStatement at 1", "operations": ["INS BooleanLiteral: true to ReturnStatement at 0", "INS Block to IfStatement at 1", "INS ReturnStatement to Block at 0"]}, {"root": "UPDATE from Maps to edges", "operations": ["UPD SimpleName: Maps from Maps to edges"]}, {"root": "MOVE from MethodInvocation", "operations": ["MOV SimpleName: Maps to MethodInvocation at 1"]}, {"root": "INS MethodInvocation to MethodInvocation at 0", "operations": ["INS MethodInvocation to MethodInvocation at 0"]}, {"root": "INS NullLiteral to MethodInvocation at 4", "operations": ["INS NullLiteral to MethodInvocation at 4"]}, {"root": "UPDATE from nodeToVisitState to graph", "operations": ["UPD SimpleName: nodeToVisitState from nodeToVisitState to graph"]}, {"root": "MOVE from MethodInvocation", "operations": ["MOV SimpleName: get to MethodInvocation at 1", "MOV SimpleName: nodeToVisitState to MethodInvocation at 0"]}, {"root": "UPDATE from get to nodes", "operations": ["UPD SimpleName: get from get to nodes"]}, {"root": "MOVE from MethodInvocation", "operations": ["MOV SimpleName: successor to MethodInvocation at 4", "MOV SimpleName: isSubgraphCyclic to MethodInvocation at 0", "MOV SimpleName: graph to MethodInvocation at 1", "MOV SimpleName: nodeToVisitState to MethodInvocation at 3"]}, {"root": "DEL ExpressionStatement", "operations": ["DEL ExpressionStatement", "DEL MethodInvocation", "DEL StringLiteral: \"isCyclic() currently only works on directed graphs\"", "DEL SimpleName: checkArgument"]}, {"root": "DEL EnhancedForStatement", "operations": ["DEL InfixExpression: ==", "DEL Block", "DEL IfStatement", "DEL Block", "DEL NullLiteral", "DEL EnhancedForStatement"]}, {"root": "DEL MethodRef", "operations": ["DEL SimpleName: isCyclic", "DEL MethodRefParameter", "DEL SimpleName: Graph", "DEL MethodRef", "DEL SimpleType: Graph"]}, {"root": "DEL TagElement: @code", "operations": ["DEL TagElement: @code"]}, {"root": "DEL NullLiteral", "operations": ["DEL NullLiteral"]}, {"root": "DEL MethodInvocation", "operations": ["DEL MethodInvocation"]}, {"root": "DEL Block", "operations": ["DEL SimpleName: put", "DEL MethodInvocation", "DEL QualifiedName: NodeVisitState.PENDING", "DEL Block", "DEL IfStatement", "DEL Block", "DEL IfStatement", "DEL EnhancedForStatement", "DEL SimpleName: nodeToVisitState", "DEL ExpressionStatement", "DEL SimpleName: node", "DEL Block"]}]}}, {"GraphProperties_diff": {"operations": ["Move ImportDeclaration(3) into CompilationUnit(342) at 3", "Insert ImportDeclaration(11) into CompilationUnit(342) at 5", "Update QualifiedName: com.google.common.base.Preconditions.checkArgument(2) to com.google.common.base.Objects", "Insert QualifiedName: javax.annotation.Nullable(10) into ImportDeclaration(11) at 0", "Insert MethodDeclaration(321) into TypeDeclaration: class(341) at 9", "Insert SingleVariableDeclaration(212) into MethodDeclaration(277) at 8", "Insert Block(276) into MethodDeclaration(277) at 9", "Insert Javadoc(283) into MethodDeclaration(321) at 0", "Insert Modifier: private(284) into MethodDeclaration(321) at 1", "Insert Modifier: static(285) into MethodDeclaration(321) at 2", "Insert PrimitiveType: boolean(286) into MethodDeclaration(321) at 3", "Insert SimpleName: canTraverseWithoutReusingEdge(287) into MethodDeclaration(321) at 4", "Insert SingleVariableDeclaration(293) into MethodDeclaration(321) at 5", "Insert SingleVariableDeclaration(297) into MethodDeclaration(321) at 6", "Insert SingleVariableDeclaration(303) into MethodDeclaration(321) at 7", "Insert Block(320) into MethodDeclaration(321) at 8", "Update SimpleName: NodeVisitState(225) to NodeState", "Insert IfStatement(65) into Block(121) at 1", "Insert IfStatement(81) into Block(121) at 2", "Insert VariableDeclarationStatement(99) into Block(121) at 3", "Insert EnhancedForStatement(118) into Block(121) at 4", "Insert IfStatement(167) into Block(174) at 0", "Move TextElement:  reachable from(127) into TagElement(182) at 4", "Update ParameterizedType: Map<Object,NodeVisitState>(149) to Map<Object,NodeState>", "Update SimpleName: nodeToVisitState(150) to visitedNodes", "Insert MarkerAnnotation(208) into SingleVariableDeclaration(212) at 0", "Insert SimpleType: Object(210) into SingleVariableDeclaration(212) at 1", "Insert SimpleName: previousNode(211) into SingleVariableDeclaration(212) at 2", "Move VariableDeclarationStatement(178) into Block(276) at 0", "Insert IfStatement(228) into Block(276) at 1", "Insert IfStatement(235) into Block(276) at 2", "Insert ExpressionStatement(241) into Block(276) at 3", "Insert EnhancedForStatement(267) into Block(276) at 4", "Move ExpressionStatement(207) into Block(276) at 5", "Move ReturnStatement(209) into Block(276) at 6", "Insert TagElement(282) into Javadoc(283) at 0", "Insert ParameterizedType: Graph<?>(291) into SingleVariableDeclaration(293) at 0", "Insert SimpleName: graph(292) into SingleVariableDeclaration(293) at 1", "Insert SimpleType: Object(295) into SingleVariableDeclaration(297) at 0", "Insert SimpleName: nextNode(296) into SingleVariableDeclaration(297) at 1", "Insert MarkerAnnotation(299) into SingleVariableDeclaration(303) at 0", "Insert SimpleType: Object(301) into SingleVariableDeclaration(303) at 1", "Insert SimpleName: previousNode(302) into SingleVariableDeclaration(303) at 2", "Insert IfStatement(317) into Block(320) at 0", "Insert ReturnStatement(319) into Block(320) at 1", "Update TextElement:  has at least one cycle.(32) to  has at least one cycle. A cycle is defined as a non-empty", "Insert TextElement: subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges)(35) into TagElement(38) at 3", "Insert TextElement: starting and ending with the same node.(36) into TagElement(38) at 4", "Insert TextElement: <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1).(37) into TagElement(38) at 5", "Insert PrimitiveType: int(50) into VariableDeclarationStatement(58) at 0", "Insert InfixExpression: ==(61) into IfStatement(65) at 0", "Insert Block(64) into IfStatement(65) at 1", "Insert InfixExpression: &&(77) into IfStatement(81) at 0", "Move Block(85) into IfStatement(81) at 1", "Update ParameterizedType: Map<Object,NodeVisitState>(58) to Map<Object,NodeState>", "Move ParameterizedType: Map<Object,NodeVisitState>(58) into VariableDeclarationStatement(99) at 0", "Insert VariableDeclarationFragment(98) into VariableDeclarationStatement(99) at 1", "Move SingleVariableDeclaration(68) into EnhancedForStatement(118) at 0", "Move MethodInvocation(71) into EnhancedForStatement(118) at 1", "Insert Block(117) into EnhancedForStatement(118) at 2", "Update TextElement: See (95) to Returns true iff ", "Update TagElement: @link(101) to @code", "Insert TextElement:  has at least one cycle. A cycle is defined as a non-empty(126) into TagElement(130) at 2", "Insert TextElement: subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges)(127) into TagElement(130) at 3", "Update TextElement: .(102) to starting and ending with the same node.", "Insert TextElement: <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1).(129) into TagElement(130) at 5", "Insert InfixExpression: &&(163) into IfStatement(167) at 0", "Move Block(184) into IfStatement(167) at 1", "Update TextElement: Returns true iff there is a cycle in the subgraph of (124) to Performs a traversal of the nodes reachable from ", "Update TextElement:  graph(125) to . If we ever reach a node we've", "Move TextElement:  graph(125) into TagElement(182) at 3", "Update TextElement:  reachable from(127) to already visited (following only outgoing edges and without reusing edges), we know there's a", "Update TextElement: .(130) to cycle in the graph.", "Update SimpleType: NodeVisitState(148) to NodeState", "Insert SimpleName: Nullable(207) into MarkerAnnotation(208) at 0", "Insert SimpleName: Object(209) into SimpleType: Object(210) at 0", "Update SimpleType: NodeVisitState(171) to NodeState", "Move InfixExpression: ==(181) into IfStatement(228) at 0", "Insert Block(227) into IfStatement(228) at 1", "Move InfixExpression: ==(187) into IfStatement(235) at 0", "Move Block(195) into IfStatement(235) at 1", "Insert MethodInvocation(240) into ExpressionStatement(241) at 0", "Move SingleVariableDeclaration(165) into EnhancedForStatement(267) at 0", "Move MethodInvocation(169) into EnhancedForStatement(267) at 1", "Insert Block(266) into EnhancedForStatement(267) at 2", "Insert TextElement: Determines whether an edge has already been used during traversal. In the directed case a cycle(278) into TagElement(282) at 0", "Insert TextElement: is always detected before reusing an edge, so no special logic is required. In the undirected(279) into TagElement(282) at 1", "Insert TextElement: case, we must take care not to \"backtrack\" over an edge (i.e. going from A to B and then going(280) into TagElement(282) at 2", "Insert TextElement: from B to A).(281) into TagElement(282) at 3", "Insert SimpleType: Graph(289) into ParameterizedType: Graph<?>(291) at 0", "Insert WildcardType: ?(290) into ParameterizedType: Graph<?>(291) at 1", "Insert SimpleName: Object(294) into SimpleType: Object(295) at 0", "Insert SimpleName: Nullable(298) into MarkerAnnotation(299) at 0", "Insert SimpleName: Object(300) into SimpleType: Object(301) at 0", "Insert InfixExpression: ||(313) into IfStatement(317) at 0", "Insert Block(316) into IfStatement(317) at 1", "Insert BooleanLiteral: false(318) into ReturnStatement(319) at 0", "Update SimpleName: nodeToVisitState(59) to numEdges", "Insert SimpleName: numEdges(59) into InfixExpression: ==(61) at 0", "Insert NumberLiteral: 0(60) into InfixExpression: ==(61) at 1", "Insert ReturnStatement(63) into Block(64) at 0", "Insert PrefixExpression: !(69) into InfixExpression: &&(77) at 0", "Insert InfixExpression: >=(76) into InfixExpression: &&(77) at 1", "Update SimpleType: NodeVisitState(57) to NodeState", "Insert SimpleName: visitedNodes(89) into VariableDeclarationFragment(98) at 0", "Insert MethodInvocation(97) into VariableDeclarationFragment(98) at 1", "Move IfStatement(86) into Block(117) at 0", "Insert TextElement:  network(124) into TagElement: @code(125) at 0", "Insert PrefixExpression: !(146) into InfixExpression: &&(163) at 0", "Insert MethodInvocation(149) into InfixExpression: &&(163) at 1", "Insert InfixExpression: >(162) into InfixExpression: &&(163) at 2", "Update SimpleName: NodeVisitState(147) to NodeState", "Update SimpleName: NodeVisitState(170) to NodeState", "Update SimpleName: nodeVisitState(172) to state", "Update SimpleName: nodeVisitState(179) to state", "Update QualifiedName: NodeVisitState.PENDING(180) to NodeState.COMPLETE", "Insert ReturnStatement(226) into Block(227) at 0", "Update SimpleName: nodeVisitState(185) to state", "Insert QualifiedName: NodeState.PENDING(230) into InfixExpression: ==(231) at 1", "Insert SimpleName: visitedNodes(236) into MethodInvocation(240) at 0", "Insert SimpleName: put(237) into MethodInvocation(240) at 1", "Insert SimpleName: node(238) into MethodInvocation(240) at 2", "Insert QualifiedName: NodeState.PENDING(239) into MethodInvocation(240) at 3", "Update SimpleName: successor(164) to nextNode", "Move IfStatement(196) into Block(266) at 0", "Update SimpleName: nodeToVisitState(202) to visitedNodes", "Update QualifiedName: NodeVisitState.COMPLETE(205) to NodeState.COMPLETE", "Insert SimpleName: Graph(288) into SimpleType: Graph(289) at 0", "Insert MethodInvocation(306) into InfixExpression: ||(313) at 0", "Insert PrefixExpression: !(312) into InfixExpression: ||(313) at 1", "Insert ReturnStatement(315) into Block(316) at 0", "Insert MethodInvocation(54) into MethodInvocation(56) at 0", "Update SimpleName: newHashMap(61) to size", "Insert BooleanLiteral: false(62) into ReturnStatement(63) at 0", "Move MethodInvocation(48) into PrefixExpression: !(69) at 0", "Insert SimpleName: numEdges(70) into InfixExpression: >=(76) at 0", "Move MethodInvocation(75) into InfixExpression: >=(76) at 1", "Update SimpleName: NodeVisitState(56) to NodeState", "Insert SimpleName: Maps(90) into MethodInvocation(97) at 0", "Insert SimpleName: newHashMapWithExpectedSize(91) into MethodInvocation(97) at 1", "Insert MethodInvocation(96) into MethodInvocation(97) at 2", "Insert Block(115) into IfStatement(116) at 1", "Insert MethodInvocation(145) into PrefixExpression: !(146) at 0", "Insert SimpleName: network(147) into MethodInvocation(149) at 0", "Insert SimpleName: allowsParallelEdges(148) into MethodInvocation(149) at 1", "Insert MethodInvocation(154) into InfixExpression: >(162) at 0", "Insert MethodInvocation(161) into InfixExpression: >(162) at 1", "Update SimpleName: nodeToVisitState(173) to visitedNodes", "Update SimpleName: successor(175) to node", "Insert BooleanLiteral: false(225) into ReturnStatement(226) at 0", "Insert InfixExpression: &&(261) into IfStatement(265) at 0", "Insert Block(264) into IfStatement(265) at 1", "Insert SimpleName: graph(304) into MethodInvocation(306) at 0", "Insert SimpleName: isDirected(305) into MethodInvocation(306) at 1", "Insert MethodInvocation(311) into PrefixExpression: !(312) at 0", "Insert BooleanLiteral: true(314) into ReturnStatement(315) at 0", "Insert SimpleName: graph(52) into MethodInvocation(54) at 0", "Update SimpleName: Maps(60) to edges", "Move SimpleName: Maps(60) into MethodInvocation(54) at 1", "Insert MethodInvocation(73) into MethodInvocation(75) at 0", "Update SimpleName: node(74) to size", "Insert MethodInvocation(94) into MethodInvocation(96) at 0", "Insert SimpleName: size(95) into MethodInvocation(96) at 1", "Update SimpleName: nodeToVisitState(80) to visitedNodes", "Insert NullLiteral(111) into MethodInvocation(112) at 4", "Insert ReturnStatement(114) into Block(115) at 0", "Insert SimpleName: network(143) into MethodInvocation(145) at 0", "Insert SimpleName: isDirected(144) into MethodInvocation(145) at 1", "Insert MethodInvocation(152) into MethodInvocation(154) at 0", "Insert SimpleName: size(153) into MethodInvocation(154) at 1", "Insert MethodInvocation(159) into MethodInvocation(161) at 0", "Insert SimpleName: size(160) into MethodInvocation(161) at 1", "Insert MethodInvocation(254) into InfixExpression: &&(261) at 0", "Insert MethodInvocation(260) into InfixExpression: &&(261) at 1", "Insert ReturnStatement(263) into Block(264) at 0", "Insert SimpleName: Objects(307) into MethodInvocation(311) at 0", "Insert SimpleName: equal(308) into MethodInvocation(311) at 1", "Insert SimpleName: previousNode(309) into MethodInvocation(311) at 2", "Insert SimpleName: nextNode(310) into MethodInvocation(311) at 3", "Update SimpleName: nodeToVisitState(72) to graph", "Move SimpleName: nodeToVisitState(72) into MethodInvocation(73) at 0", "Update SimpleName: get(73) to nodes", "Move SimpleName: get(73) into MethodInvocation(73) at 1", "Insert SimpleName: graph(92) into MethodInvocation(94) at 0", "Insert SimpleName: nodes(93) into MethodInvocation(94) at 1", "Insert BooleanLiteral: true(113) into ReturnStatement(114) at 0", "Insert SimpleName: network(150) into MethodInvocation(152) at 0", "Insert SimpleName: edges(151) into MethodInvocation(152) at 1", "Insert MethodInvocation(157) into MethodInvocation(159) at 0", "Insert SimpleName: edges(158) into MethodInvocation(159) at 1", "Insert SimpleName: canTraverseWithoutReusingEdge(250) into MethodInvocation(254) at 0", "Insert SimpleName: graph(251) into MethodInvocation(254) at 1", "Insert SimpleName: nextNode(252) into MethodInvocation(254) at 2", "Insert SimpleName: previousNode(253) into MethodInvocation(254) at 3", "Move SimpleName: isSubgraphCyclic(188) into MethodInvocation(260) at 0", "Move SimpleName: graph(189) into MethodInvocation(260) at 1", "Insert SimpleName: visitedNodes(257) into MethodInvocation(260) at 2", "Update SimpleName: nodeToVisitState(190) to nextNode", "Move SimpleName: nodeToVisitState(190) into MethodInvocation(260) at 3", "Update SimpleName: successor(191) to node", "Move SimpleName: successor(191) into MethodInvocation(260) at 4", "Insert BooleanLiteral: true(262) into ReturnStatement(263) at 0", "Insert SimpleName: network(155) into MethodInvocation(157) at 0", "Insert SimpleName: asGraph(156) into MethodInvocation(157) at 1", "Delete SimpleName: checkArgument(45)", "Delete StringLiteral: \"isCyclic() currently only works on directed graphs\"(49)", "Delete MethodInvocation(50)", "Delete ExpressionStatement(51)", "Delete NullLiteral(76)", "Delete InfixExpression: ==(77)", "Delete Block(87)", "Delete IfStatement(88)", "Delete Block(89)", "Delete EnhancedForStatement(90)", "Delete SimpleName: isCyclic(96)", "Delete SimpleName: Graph(97)", "Delete SimpleType: Graph(98)", "Delete MethodRefParameter(99)", "Delete MethodRef(100)", "Delete TagElement: @code(126)", "Delete NullLiteral(186)", "Delete MethodInvocation(192)", "Delete SimpleName: nodeToVisitState(156)", "Delete SimpleName: put(157)", "Delete SimpleName: node(158)", "Delete QualifiedName: NodeVisitState.PENDING(159)", "Delete MethodInvocation(160)", "Delete ExpressionStatement(161)", "Delete Block(197)", "Delete IfStatement(198)", "Delete IfStatement(199)", "Delete Block(200)", "Delete EnhancedForStatement(201)", "Delete Block(210)"]}}], "commit_stats": [{"total_files": 2, "deleted_files": 0, "testing": "True", "maintenance": "False", "build": "False"}]}